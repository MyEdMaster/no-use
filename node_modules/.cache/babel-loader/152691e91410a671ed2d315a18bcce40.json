{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\yuwei\\\\Desktop\\\\Front_End\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useState } from 'react';\n\nvar useSpeechSynthesis = function useSpeechSynthesis() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _props$onEnd = props.onEnd,\n      onEnd = _props$onEnd === void 0 ? function () {} : _props$onEnd;\n\n  var _useState = useState([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      voices = _useState2[0],\n      setVoices = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      speaking = _useState4[0],\n      setSpeaking = _useState4[1];\n\n  var supported = !!window.speechSynthesis;\n\n  var processVoices = function processVoices(voiceOptions) {\n    setVoices(voiceOptions);\n  };\n\n  var getVoices = function getVoices() {\n    // Firefox seems to have voices upfront and never calls the\n    // voiceschanged event\n    var voiceOptions = window.speechSynthesis.getVoices();\n\n    if (voiceOptions.length > 0) {\n      processVoices(voiceOptions);\n      return;\n    }\n\n    window.speechSynthesis.onvoiceschanged = function (event) {\n      voiceOptions = event.target.getVoices();\n      processVoices(voiceOptions);\n    };\n  };\n\n  var handleEnd = function handleEnd() {\n    setSpeaking(false);\n    onEnd();\n  };\n\n  useEffect(function () {\n    if (supported) {\n      getVoices();\n    }\n  }, []);\n\n  var speak = function speak() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _args$voice = args.voice,\n        voice = _args$voice === void 0 ? null : _args$voice,\n        _args$text = args.text,\n        text = _args$text === void 0 ? '' : _args$text;\n    setSpeaking(true); // Firefox won't repeat an utterance that has been\n    // spoken, so we need to create a new instance each time\n\n    var utterance = new window.SpeechSynthesisUtterance();\n    utterance.text = text;\n    utterance.voice = voice;\n    utterance.onend = handleEnd;\n    window.speechSynthesis.speak(utterance);\n  };\n\n  var cancel = function cancel() {\n    setSpeaking(false);\n    window.speechSynthesis.cancel();\n  };\n\n  return {\n    supported: supported,\n    speak: speak,\n    speaking: speaking,\n    cancel: cancel,\n    voices: voices\n  };\n};\n\nexport default useSpeechSynthesis;","map":{"version":3,"sources":["C:\\Users\\yuwei\\Desktop\\Front_End\\src\\page\\Speak\\useSpeechSynthesis.jsx"],"names":["useEffect","useState","useSpeechSynthesis","props","onEnd","voices","setVoices","speaking","setSpeaking","supported","window","speechSynthesis","processVoices","voiceOptions","getVoices","length","onvoiceschanged","event","target","handleEnd","speak","args","voice","text","utterance","SpeechSynthesisUtterance","onend","cancel"],"mappings":";AAAA,SACEA,SADF,EAEEC,QAFF,QAGO,OAHP;;AAKA,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,GAAgB;AAAA,MAAfC,KAAe,uEAAP,EAAO;AAAA,qBACZA,KADY,CACjCC,KADiC;AAAA,MACjCA,KADiC,6BACzB,YAAM,CAAE,CADiB;;AAAA,kBAEbH,QAAQ,CAAC,EAAD,CAFK;AAAA;AAAA,MAElCI,MAFkC;AAAA,MAE1BC,SAF0B;;AAAA,mBAGTL,QAAQ,CAAC,KAAD,CAHC;AAAA;AAAA,MAGlCM,QAHkC;AAAA,MAGxBC,WAHwB;;AAIzC,MAAMC,SAAS,GAAG,CAAC,CAACC,MAAM,CAACC,eAA3B;;AAEA,MAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,YAAD,EAAkB;AACtCP,IAAAA,SAAS,CAACO,YAAD,CAAT;AACD,GAFD;;AAIA,MAAMC,SAAS,GAAG,SAAZA,SAAY,GAAM;AACtB;AACA;AACA,QAAID,YAAY,GAAGH,MAAM,CAACC,eAAP,CAAuBG,SAAvB,EAAnB;;AACA,QAAID,YAAY,CAACE,MAAb,GAAsB,CAA1B,EAA6B;AAC3BH,MAAAA,aAAa,CAACC,YAAD,CAAb;AACA;AACD;;AAEDH,IAAAA,MAAM,CAACC,eAAP,CAAuBK,eAAvB,GAAyC,UAACC,KAAD,EAAW;AAClDJ,MAAAA,YAAY,GAAGI,KAAK,CAACC,MAAN,CAAaJ,SAAb,EAAf;AACAF,MAAAA,aAAa,CAACC,YAAD,CAAb;AACD,KAHD;AAID,GAbD;;AAeA,MAAMM,SAAS,GAAG,SAAZA,SAAY,GAAM;AACtBX,IAAAA,WAAW,CAAC,KAAD,CAAX;AACAJ,IAAAA,KAAK;AACN,GAHD;;AAKAJ,EAAAA,SAAS,CAAC,YAAM;AACd,QAAIS,SAAJ,EAAe;AACbK,MAAAA,SAAS;AACV;AACF,GAJQ,EAIN,EAJM,CAAT;;AAMA,MAAMM,KAAK,GAAG,SAARA,KAAQ,GAAe;AAAA,QAAdC,IAAc,uEAAP,EAAO;AAAA,sBACSA,IADT,CACnBC,KADmB;AAAA,QACnBA,KADmB,4BACX,IADW;AAAA,qBACSD,IADT,CACLE,IADK;AAAA,QACLA,IADK,2BACE,EADF;AAE3Bf,IAAAA,WAAW,CAAC,IAAD,CAAX,CAF2B,CAG3B;AACA;;AACA,QAAMgB,SAAS,GAAG,IAAId,MAAM,CAACe,wBAAX,EAAlB;AACAD,IAAAA,SAAS,CAACD,IAAV,GAAiBA,IAAjB;AACAC,IAAAA,SAAS,CAACF,KAAV,GAAkBA,KAAlB;AACAE,IAAAA,SAAS,CAACE,KAAV,GAAkBP,SAAlB;AACAT,IAAAA,MAAM,CAACC,eAAP,CAAuBS,KAAvB,CAA6BI,SAA7B;AACD,GAVD;;AAYA,MAAMG,MAAM,GAAG,SAATA,MAAS,GAAM;AACnBnB,IAAAA,WAAW,CAAC,KAAD,CAAX;AACAE,IAAAA,MAAM,CAACC,eAAP,CAAuBgB,MAAvB;AACD,GAHD;;AAKA,SAAO;AACLlB,IAAAA,SAAS,EAATA,SADK;AAELW,IAAAA,KAAK,EAALA,KAFK;AAGLb,IAAAA,QAAQ,EAARA,QAHK;AAILoB,IAAAA,MAAM,EAANA,MAJK;AAKLtB,IAAAA,MAAM,EAANA;AALK,GAAP;AAOD,CA5DD;;AA8DA,eAAeH,kBAAf","sourcesContent":["import {\n  useEffect,\n  useState\n} from 'react';\n\nconst useSpeechSynthesis = (props = {}) => {\n  const { onEnd = () => {} } = props;\n  const [voices, setVoices] = useState([]);\n  const [speaking, setSpeaking] = useState(false);\n  const supported = !!window.speechSynthesis;\n\n  const processVoices = (voiceOptions) => {\n    setVoices(voiceOptions);\n  };\n\n  const getVoices = () => {\n    // Firefox seems to have voices upfront and never calls the\n    // voiceschanged event\n    let voiceOptions = window.speechSynthesis.getVoices();\n    if (voiceOptions.length > 0) {\n      processVoices(voiceOptions);\n      return;\n    }\n\n    window.speechSynthesis.onvoiceschanged = (event) => {\n      voiceOptions = event.target.getVoices();\n      processVoices(voiceOptions);\n    };\n  };\n\n  const handleEnd = () => {\n    setSpeaking(false);\n    onEnd();\n  };\n\n  useEffect(() => {\n    if (supported) {\n      getVoices();\n    }\n  }, []);\n\n  const speak = (args = {}) => {\n    const { voice = null, text = '' } = args;\n    setSpeaking(true);\n    // Firefox won't repeat an utterance that has been\n    // spoken, so we need to create a new instance each time\n    const utterance = new window.SpeechSynthesisUtterance();\n    utterance.text = text;\n    utterance.voice = voice;\n    utterance.onend = handleEnd;\n    window.speechSynthesis.speak(utterance);\n  };\n\n  const cancel = () => {\n    setSpeaking(false);\n    window.speechSynthesis.cancel();\n  };\n\n  return {\n    supported,\n    speak,\n    speaking,\n    cancel,\n    voices\n  };\n};\n\nexport default useSpeechSynthesis;\n"]},"metadata":{},"sourceType":"module"}
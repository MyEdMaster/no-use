{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _react = require('react');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar propTypes = {\n  children: _propTypes2.default.func.isRequired,\n  onEnd: _propTypes2.default.func,\n  onResult: _propTypes2.default.func\n};\nvar defaultProps = {\n  onEnd: function onEnd() {},\n  onResult: function onResult() {}\n};\nwindow.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n\nvar SpeechRekognition = function SpeechRekognition(props) {\n  var recognition = (0, _react.useRef)(null);\n\n  var _useState = (0, _react.useState)(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      listening = _useState2[0],\n      setListening = _useState2[1];\n\n  var supported = !!window.SpeechRecognition;\n  var children = props.children,\n      onEnd = props.onEnd,\n      onResult = props.onResult;\n\n  var processResult = function processResult(event) {\n    var transcript = Array.from(event.results).map(function (result) {\n      return result[0];\n    }).map(function (result) {\n      return result.transcript;\n    }).join('');\n    onResult(transcript);\n  };\n\n  var listen = function listen() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (listening) return;\n    var _args$lang = args.lang,\n        lang = _args$lang === undefined ? '' : _args$lang,\n        _args$interimResults = args.interimResults,\n        interimResults = _args$interimResults === undefined ? true : _args$interimResults;\n    setListening(true);\n    recognition.current.lang = lang;\n    recognition.current.interimResults = interimResults;\n    recognition.current.onresult = processResult; // SpeechRecognition stops automatically after inactivity\n    // We want it to keep going until we tell it to stop\n\n    recognition.current.onend = function () {\n      return recognition.current.start();\n    };\n\n    recognition.current.start();\n  };\n\n  var stop = function stop() {\n    if (!listening) return;\n    setListening(false);\n\n    recognition.current.onend = function () {};\n\n    recognition.current.stop();\n    onEnd();\n  };\n\n  (0, _react.useEffect)(function () {\n    if (!supported) return;\n    recognition.current = new window.SpeechRecognition();\n  }, []);\n  return children({\n    listen: listen,\n    listening: listening,\n    stop: stop,\n    supported: supported\n  });\n};\n\nSpeechRekognition.propTypes = propTypes;\nSpeechRekognition.defaultProps = defaultProps;\nexports.default = (0, _react.memo)(SpeechRekognition);","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\yuwei\\\\Desktop\\\\Front_End\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { memo, useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nvar propTypes = {\n  children: PropTypes.func.isRequired,\n  onEnd: PropTypes.func\n};\nvar defaultProps = {\n  onEnd: function onEnd() {}\n};\n\nvar SpeechSynthesis = function SpeechSynthesis(props) {\n  var onEnd = props.onEnd,\n      children = props.children;\n\n  var _useState = useState([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      voices = _useState2[0],\n      setVoices = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      speaking = _useState4[0],\n      setSpeaking = _useState4[1];\n\n  var supported = !!window.speechSynthesis;\n\n  var processVoices = function processVoices(voiceOptions) {\n    setVoices(voiceOptions);\n  };\n\n  var getVoices = function getVoices() {\n    // Firefox seems to have voices upfront and never calls the\n    // voiceschanged event\n    var voiceOptions = window.speechSynthesis.getVoices();\n\n    if (voiceOptions.length > 0) {\n      processVoices(voiceOptions);\n      return;\n    }\n\n    window.speechSynthesis.onvoiceschanged = function (event) {\n      voiceOptions = event.target.getVoices();\n      processVoices(voiceOptions);\n    };\n  };\n\n  var handleEnd = function handleEnd() {\n    setSpeaking(false);\n    onEnd();\n  };\n\n  useEffect(function () {\n    if (supported) {\n      getVoices();\n    }\n  }, []);\n\n  var speak = function speak() {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _args$voice = args.voice,\n        voice = _args$voice === void 0 ? null : _args$voice,\n        _args$text = args.text,\n        text = _args$text === void 0 ? '' : _args$text;\n    setSpeaking(true); // Firefox won't repeat an utterance that has been\n    // spoken, so we need to create a new instance each time\n\n    var utterance = new window.SpeechSynthesisUtterance();\n    utterance.text = text;\n    utterance.voice = voice;\n    utterance.onend = handleEnd;\n    window.speechSynthesis.speak(utterance);\n  };\n\n  var cancel = function cancel() {\n    setSpeaking(false);\n    window.speechSynthesis.cancel();\n  };\n\n  return children({\n    supported: supported,\n    speak: speak,\n    speaking: speaking,\n    cancel: cancel,\n    voices: voices\n  });\n};\n\nSpeechSynthesis.propTypes = propTypes;\nSpeechSynthesis.defaultProps = defaultProps;\nexport default memo(SpeechSynthesis);","map":{"version":3,"sources":["C:\\Users\\yuwei\\Desktop\\Front_End\\src\\page\\SpeakModule\\SpeechSynthesis.jsx"],"names":["memo","useEffect","useState","PropTypes","propTypes","children","func","isRequired","onEnd","defaultProps","SpeechSynthesis","props","voices","setVoices","speaking","setSpeaking","supported","window","speechSynthesis","processVoices","voiceOptions","getVoices","length","onvoiceschanged","event","target","handleEnd","speak","args","voice","text","utterance","SpeechSynthesisUtterance","onend","cancel"],"mappings":"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","sourcesContent":["import {\n  memo,\n  useEffect,\n  useState\n} from 'react';\nimport PropTypes from 'prop-types';\n\nconst propTypes = {\n  children: PropTypes.func.isRequired,\n  onEnd: PropTypes.func\n};\n\nconst defaultProps = {\n  onEnd: () => {}\n};\n\nconst SpeechSynthesis = (props) => {\n  const { onEnd, children } = props;\n  const [voices, setVoices] = useState([]);\n  const [speaking, setSpeaking] = useState(false);\n  const supported = !!window.speechSynthesis;\n\n  const processVoices = (voiceOptions) => {\n    setVoices(voiceOptions);\n  };\n\n  const getVoices = () => {\n    // Firefox seems to have voices upfront and never calls the\n    // voiceschanged event\n    let voiceOptions = window.speechSynthesis.getVoices();\n    if (voiceOptions.length > 0) {\n      processVoices(voiceOptions);\n      return;\n    }\n\n    window.speechSynthesis.onvoiceschanged = (event) => {\n      voiceOptions = event.target.getVoices();\n      processVoices(voiceOptions);\n    };\n  };\n\n  const handleEnd = () => {\n    setSpeaking(false);\n    onEnd();\n  };\n\n  useEffect(() => {\n    if (supported) {\n      getVoices();\n    }\n  }, []);\n\n  const speak = (args = {}) => {\n    const { voice = null, text = '' } = args;\n    setSpeaking(true);\n    // Firefox won't repeat an utterance that has been\n    // spoken, so we need to create a new instance each time\n    const utterance = new window.SpeechSynthesisUtterance();\n    utterance.text = text;\n    utterance.voice = voice;\n    utterance.onend = handleEnd;\n    window.speechSynthesis.speak(utterance);\n  };\n\n  const cancel = () => {\n    setSpeaking(false);\n    window.speechSynthesis.cancel();\n  };\n\n  return children({\n    supported,\n    speak,\n    speaking,\n    cancel,\n    voices\n  });\n};\n\nSpeechSynthesis.propTypes = propTypes;\nSpeechSynthesis.defaultProps = defaultProps;\n\nexport default memo(SpeechSynthesis);\n"]},"metadata":{},"sourceType":"module"}